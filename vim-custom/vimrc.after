let mapleader = ","

" remap space to :
nmap <space> :

" open files in split right and below:
set splitbelow
set splitright

" set backspace=2
set backspace=indent,eol,start

set autoindent
set autoread
set autowrite
set clipboard+=unnamed
set commentstring=\ #\ %s
set isfname+=32

" This unsets the 'last search pattern' register by hitting return
nnoremap <CR> :noh<CR><CR>

" ------------------------------------------------------------------
" Solarized Colorscheme Config
" ------------------------------------------------------------------
syntax enable
set background=light
colorscheme solarized
let g:solarized_visibility ="low"
let g:solarized_termcolors=256
let g:solarized_italic=0

:vnoremap > >gv
:vnoremap < <gv

" Alternative using Tab/Shift-Tab (for gvim).
:vnoremap <Tab> >gv
:vnoremap <S-Tab> <gv

if has("autocmd")
  " run rspec for _spec files
  autocmd BufNewFile,BufRead *_spec.rb compiler rspec
  autocmd bufwritepost .vimrc source $MYVIMRC
  autocmd BufWritePre *.py,*.js :call <SID>StripTrailingWhitespaces()
endif

" F1 for help
map <F1> <ESC>:exec "help ".expand("<cWORD>")<CR>
" Control-arrow combination for browsing the buffer
map <C-right> <ESC>:bn<CR>
map <C-left> <ESC>:bp<CR>
" open included file in a new buffer
map gf :edit <cfile><CR>

" folding with return key:
nnoremap <return> za

" tabbing between windows with tab key:
nnoremap <Tab> <C-w><C-w>

" nerdtree options:
let NERDTreeShowHidden=1
let NERDTreeShowBookmarks=1000
nmap <leader>nt :NERDTreeToggle<cr>

let g:AutoClosePairs = {'(': ')', '{': '}', '[': ']', '"': '"', "'": "'", '#{': '}', '|':'|' }
let g:AutoCloseProtectedRegions = ["Character"]

" run commands
nmap ff :! open -a /Applications/internet/Firefox.app/Contents/MacOS/firefox-bin %:p<cr>
nmap cr :! open -a /Applications/internet/Google\ Chrome.app/Contents/MacOS/Google\ Chrome %:p<cr>
nmap <Leader>v :tabedit $MYVIMRC<cr>
nmap <Leader>lv :tabedit ~/.vimrc.local<cr>
nmap <Leader>gendocs :helptags $HOME/.vim/doc<cr>
nmap <Leader>rrun :! ruby -v %:p<cr>
nmap <Leader>prun :! python -u %:p<cr>

" inoremap
inoremap <c-j> <ESC>/<+.\{-1,}+><cr>c/+>/e<cr>

" inoremap <Tab> <C-R>=SuperCleverTab()<cr>
" function! SuperCleverTab()
"     "check if at beginning of line or after a space
"     if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
"         return "\<Tab>"
"     else
"         " do we have omni completion available
"         if &omnifunc != ''
"             "use omni-completion 1. priority
"             return "\<C-X>\<C-O>"
"         elseif &dictionary != ''
"             " no omni completion, try dictionary completio
"             return "\<C-K>"
"         else
"             "use omni completion or dictionary completion
"             "use known-word completion
"             return "\<C-N>"
"         endif
"     endif
" endfunction

set autoindent

" folding settings
set foldmethod=syntax   "fold based on indent
set foldnestmax=10      "deepest fold is 3 levels
set nofoldenable        "dont fold by default

set wildmenu            "enable ctrl-n and ctrl-p to scroll thru matches

set formatoptions-=o "dont continue comments when pushing o/O

" vertical/horizontal scroll off settings
set scrolloff=3
set sidescrolloff=7
set sidescroll=1

" tell the term has 256 colors
" set t_Co=256

" hide buffers when not displayed
set hidden

" folding in coffeescript files
au BufNewFile,BufReadPost *.coffee setl foldmethod=indent

" folding in python files
au BufNewFile,BufReadPost *.py setl foldmethod=indent

" Tabularize settings
if exists(":Tabularize")
  nmap <Leader>a= :Tabularize /=<CR>
  vmap <Leader>a= :Tabularize /=<CR>
  nmap <Leader>a: :Tabularize /:\zs<CR>
  vmap <Leader>a: :Tabularize /:\zs<CR>
endif

inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a

function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
     normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction

" Unimpaired settings
" Bubble single lines
nmap <C-Up> [e
nmap <C-Down> ]e
" Bubble multiple lines
vmap <C-Up> [egv
vmap <C-Down> ]egv

" Visually select the text that was last edited/pasted
nmap gV `[v`]

" vimwiki settings
let g:vimwiki_list = [{'path': '~/.vim/_vimwiki/', 'path_html': '~/code/work/web/html/vimwiki/'}]
map <Leader>ww <Plug>VimwikiIndex

function! <SID>StripTrailingWhitespaces()
  " Preparation: save last search, and cursor position.
  let _s=@/
  let l = line(".")
  let c = col(".")
  " Do the business:
  %s/\s\+$//e
  " Clean up: restore previous search
  " history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction

" preview settings
" let g:PreviewBrowsers="google-chrome,firefox,safari"
" nmap <Leader>o :Preview<CR>

" indent guides plugin
au VimEnter * :IndentGuidesEnable
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_color_change_percent = 2

if !has("gui")
  let g:indent_guides_auto_colors = 0
  autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  ctermbg=white
  autocmd VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=lightgrey
endif

" display indentation guides with vim native method
" set tabstop=2 softtabstop=2 shiftwidth=2
" set list
" set listchars=tab:❘ ,trail:·,extends:»,precedes:«,nbsp:×

" convert spaces to tabs when reading file
" autocmd! bufreadpost * set noexpandtab | retab! 2

" convert tabs to spaces before writing file
" autocmd! bufwritepre * set expandtab | retab! 2

" convert spaces to tabs after writing file (to show guides again)
" autocmd! bufwritepost * set noexpandtab | retab! 2

" --------------------------------------------------------------------------- #
" statusline
" --------------------------------------------------------------------------- #
"store lots of :cmdline history
set history=1000
set showcmd     "show incomplete cmds down the bottom
set showmode    "show current mode down the bottom

set linebreak   "wrap lines at convenient points

"statusline setup
set statusline=%f       "tail of the filename

set pastetoggle=<F5>

"display a warning if fileformat isnt unix
set statusline+=%#warningmsg#
set statusline+=%{&ff!='unix'?'['.&ff.']':''}
set statusline+=%*

"display a warning if file encoding isnt utf-8
set statusline+=%#warningmsg#
set statusline+=%{(&fenc!='utf-8'&&&fenc!='')?'['.&fenc.']':''}
set statusline+=%*

set statusline+=%h      "help file flag
set statusline+=%y      "filetype
set statusline+=%r      "read only flag
set statusline+=%m      "modified flag

"display a warning if &et is wrong, or we have mixed-indenting
set statusline+=%#error#
set statusline+=%{StatuslineTabWarning()}
set statusline+=%*

set statusline+=%{StatuslineTrailingSpaceWarning()}

set statusline+=%{StatuslineLongLineWarning()}

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

"display a warning if &paste is set
set statusline+=%#error#
set statusline+=%{&paste?'[paste]':''}
set statusline+=%*

set statusline+=%=      "left/right separator
set statusline+=%{StatuslineCurrentHighlight()}\ \ "current highlight
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ %P    "percent through file

"recalculate the trailing whitespace warning when idle, and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_trailing_space_warning

"return '[\s]' if trailing white space is detected
"return '' otherwise
function! StatuslineTrailingSpaceWarning()
    if !exists("b:statusline_trailing_space_warning")
        if search('\s\+$', 'nw') != 0
            let b:statusline_trailing_space_warning = '[\s]'
        else
            let b:statusline_trailing_space_warning = ''
        endif
    endif
    return b:statusline_trailing_space_warning
endfunction


"return the syntax highlight group under the cursor ''
function! StatuslineCurrentHighlight()
    let name = synIDattr(synID(line('.'),col('.'),1),'name')
    if name == ''
        return ''
    else
        return '[' . name . ']'
    endif
endfunction

"recalculate the tab warning flag when idle and after writing
autocmd cursorhold,bufwritepost * unlet! b:statusline_tab_warning

"return '[&et]' if &et is set wrong
"return '[mixed-indenting]' if spaces and tabs are used to indent
"return an empty string if everything is fine
function! StatuslineTabWarning()
    if !exists("b:statusline_tab_warning")
        let tabs = search('^\t', 'nw') != 0
        let spaces = search('^ ', 'nw') != 0

        if tabs && spaces
            let b:statusline_tab_warning =  '[mixed-indenting]'
        elseif (spaces && !&et) || (tabs && &et)
            let b:statusline_tab_warning = '[&et]'
        else
            let b:statusline_tab_warning = ''
        endif
    endif
    return b:statusline_tab_warning
endfunction

"recalculate the long line warning when idle and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_long_line_warning

"return a warning for "long lines" where "long" is either &textwidth or 80 (if
"no &textwidth is set)
"
"return '' if no long lines
"return '[#x,my,$z] if long lines are found, were x is the number of long
"lines, y is the median length of the long lines and z is the length of the
"longest line
function! StatuslineLongLineWarning()
    if !exists("b:statusline_long_line_warning")
        let long_line_lens = s:LongLines()

        if len(long_line_lens) > 0
            let b:statusline_long_line_warning = "[" .
                        \ '#' . len(long_line_lens) . "," .
                        \ 'm' . s:Median(long_line_lens) . "," .
                        \ '$' . max(long_line_lens) . "]"
        else
            let b:statusline_long_line_warning = ""
        endif
    endif
    return b:statusline_long_line_warning
endfunction

"return a list containing the lengths of the long lines in this buffer
function! s:LongLines()
    let threshold = (&tw ? &tw : 80)
    let spaces = repeat(" ", &ts)

    let long_line_lens = []

    let i = 1
    while i <= line("$")
        let len = strlen(substitute(getline(i), '\t', spaces, 'g'))
        if len > threshold
            call add(long_line_lens, len)
        endif
        let i += 1
    endwhile

    return long_line_lens
endfunction

"find the median of the given array of numbers
function! s:Median(nums)
    let nums = sort(a:nums)
    let l = len(nums)

    if l % 2 == 1
        let i = (l-1) / 2
        return nums[i]
    else
        return (nums[l/2] + nums[(l/2)-1]) / 2
    endif
endfunction
